using System;
using Microsoft.Kinect;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Collections.Generic;

namespace LightBuzz.Vitruvius
{
    /// <summary>
    /// Provides some common functionality for manupulating body data.
    /// </summary>
    public static class BodyExtensions
    {
        #region Members

        static IList<Body> _bodies = null;

        #endregion

        #region Public methods

        /// <summary>
        /// Returns the bodies found in the current frame.
        /// </summary>
        /// <param name="frame">The BodyFrame generated by the Kinect sensor.</param>
        /// <returns>An array of bodies or an empty array if no bodies were found.</returns>
        public static IEnumerable<Body> Bodies(this BodyFrame frame)
        {
            if (_bodies == null)
            {
                _bodies = new Body[frame.BodyCount];
            }

            frame.GetAndRefreshBodyData(_bodies);

            return _bodies;
        }

        /// <summary>
        /// Returns the default body, aka the one that is currently in front of the Kinect sensor.
        /// </summary>
        /// <param name="bodies">A list of bodies to look at.</param>
        /// <returns>The first tracked body.</returns>
        public static Body Default(this IEnumerable<Body> bodies)
        {
            return bodies.Where(b => b.IsTracked).FirstOrDefault();
        }

        /// <summary>
        /// Retruns the height of the specified body.
        /// </summary>
        /// <param name="body">The specified user body.</param>
        /// <returns>The height of the body in meters.</returns>
        public static double Height(this Body body)
        {
            const double HEAD_DIVERGENCE = 0.1;

            var head = body.Joints[JointType.Head];
            var neck = body.Joints[JointType.Neck];
            var shoulders = body.Joints[JointType.SpineShoulder];
            var spine = body.Joints[JointType.SpineMid];
            var waist = body.Joints[JointType.SpineBase];
            var hipLeft = body.Joints[JointType.HipLeft];
            var hipRight = body.Joints[JointType.HipRight];
            var kneeLeft = body.Joints[JointType.KneeLeft];
            var kneeRight = body.Joints[JointType.KneeRight];
            var ankleLeft = body.Joints[JointType.AnkleLeft];
            var ankleRight = body.Joints[JointType.AnkleRight];
            var footLeft = body.Joints[JointType.FootLeft];
            var footRight = body.Joints[JointType.FootRight];

            // Find which leg is tracked more accurately.
            int legLeftTrackedJoints = JointExtensions.NumberOfTrackedJoints(hipLeft, kneeLeft, ankleLeft, footLeft);
            int legRightTrackedJoints = JointExtensions.NumberOfTrackedJoints(hipRight, kneeRight, ankleRight, footRight);

            double legLength = legLeftTrackedJoints > legRightTrackedJoints ? JointExtensions.Distance(hipLeft, kneeLeft, ankleLeft, footLeft) : JointExtensions.Distance(hipRight, kneeRight, ankleRight, footRight);

            return JointExtensions.Distance(head, neck, shoulders, spine, waist) + legLength + HEAD_DIVERGENCE;
        }

        /// <summary>
        /// Returns the upper height of the specified body (head to waist).
        /// </summary>
        /// <param name="body">The specified user body.</param>
        /// <returns>The upper height of the body in meters.</returns>
        public static double UpperHeight(this Body body)
        {
            var head = body.Joints[JointType.Head];
            var neck = body.Joints[JointType.Neck];
            var shoulders = body.Joints[JointType.SpineShoulder];
            var spine = body.Joints[JointType.SpineMid];
            var waist = body.Joints[JointType.SpineBase];

            return JointExtensions.Distance(head, neck, shoulders, spine, waist);
        }
                
        /// <summary>
        /// Given a collection of joints, calculates the number of the joints that are tracked accurately.
        /// </summary>
        /// <param name="joints">A collection of joints.</param>
        /// <returns>The number of the accurately tracked joints.</returns>
        public static int NumberOfTrackedJoints(this Body body)
        {
            return JointExtensions.NumberOfTrackedJoints(body.Joints.Values);
        }

        /// <summary>
        /// Converts a Vector4 quaternion to a Vector3 CameraSpacePoint.
        /// </summary>
        /// <param name="orientation">The Vector4 quaternion.</param>
        /// <returns>A Vector3 representation of the quaternion.</returns>
        public static CameraSpacePoint QuaternionToEuler(this Vector4 orientation)
        {
            CameraSpacePoint point = new CameraSpacePoint();

            point.X = (float)Math.Atan2
            (
                2 * orientation.Y * orientation.W - 2 * orientation.X * orientation.Z,
                1 - 2 * Math.Pow(orientation.Y, 2) - 2 * Math.Pow(orientation.Z, 2)
            );

            point.Y = (float)Math.Asin
            (
                2 * orientation.X * orientation.Y + 2 * orientation.Z * orientation.W
            );

            point.Z = (float)Math.Atan2
            (
                2 * orientation.X * orientation.W - 2 * orientation.Y * orientation.Z,
                1 - 2 * Math.Pow(orientation.X, 2) - 2 * Math.Pow(orientation.Z, 2)
            );

            if (orientation.X * orientation.Y + orientation.Z * orientation.W == 0.5)
            {
                point.X = (float)(2 * Math.Atan2(orientation.X, orientation.W));
                point.Z = 0;
            }

            else if (orientation.X * orientation.Y + orientation.Z * orientation.W == -0.5)
            {
                point.X = (float)(-2 * Math.Atan2(orientation.X, orientation.W));
                point.Z = 0;
            }

            return point;
        }

        /// <summary>
        /// Calculates the rotation of the specified joint orientation as a CameraSpacePoint.
        /// </summary>
        /// <param name="orientation">The orientation of a joint.</param>
        /// <returns>The joint rotation in the X, Y and Z axis.</returns>
        public static CameraSpacePoint Rotation(this JointOrientation orientation)
        {
            return orientation.Orientation.QuaternionToEuler();
        }
        
        #endregion
    }
}
